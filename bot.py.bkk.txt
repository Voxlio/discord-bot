import os
import re
import random
import sqlite3
import asyncio
from datetime import datetime, timedelta
import discord
from discord.ext import commands, tasks
from discord.ui import View, Select, Button
from io import BytesIO
import openpyxl
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet

# Optional PNG export (pure-Pillow)
try:
    from PIL import Image, ImageDraw, ImageFont
    PIL_AVAILABLE = True
except Exception:
    PIL_AVAILABLE = False

# -------------------------
# üîë Tokens & Logo  (UNCHANGED)
# -------------------------
TOKEN = "MTQxMjg5MzU1NzI2OTcyNTMxNQ.G8_FIB.a3ktJ-fU3v95uTPAkRCpx40obNgC9OHkUcKr2E"
LOGO_URL = "https://cdn.discordapp.com/attachments/993192595796787200/1413250033545121802/vox_logo.png"

# -------------------------
# ‚öôÔ∏è Bot Setup (UNCHANGED)
# -------------------------
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.presences = True
bot = commands.Bot(command_prefix="!", intents=intents)

# -------------------------
# üì¶ Storage (kept, now backed by DB)
# -------------------------
user_links = {}       # {user_id: "https://x.com/..."}
user_stats = {}       # {user_id: {"registrations": int, "wins": int}}
raffles = {}          # {raffle_name: [user_id, user_id]}  (user-facing: "spaces")
already_picked = set()
always_pick = set()
WINNER_ROLE_NAME = "Winner"

DB_PATH = "voxpicker.db"

# -------------------------
# üóÉÔ∏è Database helpers
# -------------------------
def db_conn():
    return sqlite3.connect(DB_PATH)

def db_init():
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("""
        CREATE TABLE IF NOT EXISTS users(
            user_id INTEGER PRIMARY KEY,
            x_link TEXT
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS stats(
            user_id INTEGER PRIMARY KEY,
            registrations INTEGER DEFAULT 0,
            wins INTEGER DEFAULT 0,
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS always_pick(
            user_id INTEGER PRIMARY KEY
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS raffles(
            raffle_name TEXT,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            archived INTEGER DEFAULT 0,
            PRIMARY KEY(raffle_name)
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS raffle_winners(
            raffle_name TEXT,
            user_id INTEGER,
            picked_at TEXT DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY(raffle_name, user_id),
            FOREIGN KEY(raffle_name) REFERENCES raffles(raffle_name)
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS picks_state(
            user_id INTEGER PRIMARY KEY
        );
        """)
        # NEW: schedule archiving after export
        cur.execute("""
        CREATE TABLE IF NOT EXISTS archive_schedule(
            raffle_name TEXT PRIMARY KEY,
            archive_at TEXT
        );
        """)
	# üî• New blacklist table
        cur.execute("""
        CREATE TABLE IF NOT EXISTS blacklist(
            user_id INTEGER PRIMARY KEY
        )""")
        con.commit()

def load_state_from_db():
    # users + links
    with db_conn() as con:
        cur = con.cursor()
        for uid, link in cur.execute("SELECT user_id, x_link FROM users"):
            user_links[uid] = link or ""
        # stats
        for uid, reg, wins in cur.execute("SELECT user_id, registrations, wins FROM stats"):
            user_stats[uid] = {"registrations": reg or 0, "wins": wins or 0}
        # always_pick
        always_pick.clear()
        for (uid,) in cur.execute("SELECT user_id FROM always_pick"):
            always_pick.add(uid)
        # raffles (active only)
        raffles.clear()
        for (name,) in cur.execute("SELECT raffle_name FROM raffles WHERE archived = 0"):
            raffles[name] = []
        # winners for active raffles
        for name, uid in cur.execute("""
            SELECT raffle_name, user_id FROM raffle_winners
            JOIN raffles USING(raffle_name)
            WHERE raffles.archived = 0
        """):
            raffles.setdefault(name, []).append(uid)
        # already_picked
        already_picked.clear()
        for (uid,) in cur.execute("SELECT user_id FROM picks_state"):
            already_picked.add(uid)

def db_upsert_user(user_id: int, link: str):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT INTO users(user_id, x_link) VALUES(?, ?) ON CONFLICT(user_id) DO UPDATE SET x_link=excluded.x_link", (user_id, link))
        cur.execute("INSERT INTO stats(user_id, registrations, wins) VALUES(?, 0, 0) ON CONFLICT(user_id) DO NOTHING", (user_id,))
        con.commit()

def db_update_stat(user_id: int, delta_reg: int = 0, delta_wins: int = 0):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("""
        INSERT INTO stats(user_id, registrations, wins) VALUES(?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
            registrations = registrations + ?,
            wins = wins + ?
        """, (user_id, max(delta_reg,0), max(delta_wins,0), delta_reg, delta_wins))
        con.commit()

def db_set_always(user_id: int, add=True):
    with db_conn() as con:
        cur = con.cursor()
        if add:
            cur.execute("INSERT OR IGNORE INTO always_pick(user_id) VALUES(?)", (user_id,))
        else:
            cur.execute("DELETE FROM always_pick WHERE user_id=?", (user_id,))
        con.commit()

def db_set_picked(user_id: int, add=True):
    with db_conn() as con:
        cur = con.cursor()
        if add:
            cur.execute("INSERT OR IGNORE INTO picks_state(user_id) VALUES(?)", (user_id,))
        else:
            cur.execute("DELETE FROM picks_state WHERE user_id=?", (user_id,))
        con.commit()

def db_reset_picks(clear_all=True):
    # clear_all=True -> remove everyone (including always-pick) from already_picked
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("DELETE FROM picks_state")
        con.commit()

def db_create_raffle(raffle_name: str):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT OR IGNORE INTO raffles(raffle_name, archived) VALUES(?, 0)", (raffle_name,))
        con.commit()

def db_add_winner(raffle_name: str, user_id: int):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT OR IGNORE INTO raffle_winners(raffle_name, user_id, picked_at) VALUES(?, ?, ?)",
                    (raffle_name, user_id, datetime.utcnow().isoformat()))
        con.commit()

def db_archive_raffle(raffle_name: str):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("UPDATE raffles SET archived = 1 WHERE raffle_name = ?", (raffle_name,))
        cur.execute("DELETE FROM archive_schedule WHERE raffle_name=?", (raffle_name,))
        con.commit()

def db_is_archived(raffle_name: str) -> bool:
    with db_conn() as con:
        cur = con.cursor()
        row = cur.execute("SELECT archived FROM raffles WHERE raffle_name=?", (raffle_name,)).fetchone()
        return bool(row and row[0] == 1)

def db_get_active_raffles():
    with db_conn() as con:
        cur = con.cursor()
        return [r[0] for r in cur.execute("SELECT raffle_name FROM raffles WHERE archived = 0")]

def db_get_archived_raffles():
    with db_conn() as con:
        cur = con.cursor()
        return [r[0] for r in cur.execute("SELECT raffle_name FROM raffles WHERE archived = 1")]

def db_schedule_archive(raffle_name: str, when: datetime):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT OR REPLACE INTO archive_schedule(raffle_name, archive_at) VALUES(?, ?)",
                    (raffle_name, when.isoformat()))
        con.commit()

def db_get_due_archives(now: datetime):
    with db_conn() as con:
        cur = con.cursor()
        return [r[0] for r in cur.execute("SELECT raffle_name FROM archive_schedule WHERE archive_at <= ?", (now.isoformat(),))]

def db_user_wins(user_id: int):
    with db_conn() as con:
        cur = con.cursor()
        return [row[0] for row in cur.execute("""
            SELECT raffle_name FROM raffle_winners
            JOIN raffles USING(raffle_name)
            WHERE user_id=?""", (user_id,))]

def is_blacklisted(user_id: int) -> bool:
    with db_conn() as con:
        cur = con.cursor()
        row = cur.execute("SELECT 1 FROM blacklist WHERE user_id=?", (user_id,)).fetchone()
        return row is not None

# -------------------------
# ‚è±Ô∏è Background: handle scheduled archives
# -------------------------
@tasks.loop(seconds=30.0)
async def archive_watcher():
    now = datetime.utcnow()
    due = db_get_due_archives(now)
    if not due:
        return
    for name in due:
        # Mark archived in DB
        db_archive_raffle(name)
        # Remove from in-memory active list
        raffles.pop(name, None)

@archive_watcher.before_loop
async def before_archive_watcher():
    await bot.wait_until_ready()

# -------------------------
# üöÄ Events
# -------------------------
@bot.event
async def on_ready():
    db_init()
    load_state_from_db()
    archive_watcher.start()
    print(f"‚úÖ Bot is online as {bot.user}")

# -------------------------
# üìù Commands (kept; logic backed by DB)
# -------------------------
@bot.command()
async def hello(ctx):
    await ctx.send(f"Hello {ctx.author.mention}! üëã")

@bot.command()
async def register(ctx, link: str = None):
    """Register your X (Twitter) link"""
    if not link:
        await ctx.send("‚ö†Ô∏è Please provide your X profile link. Example: `!register https://x.com/username`")
        return
    pattern = r"^https:\/\/(x\.com|twitter\.com)\/[A-Za-z0-9_]+$"
    if not re.match(pattern, link):
        await ctx.send("‚ùå Invalid link! Example: `https://x.com/username`")
        return
    if ctx.author.id in user_links:
        await ctx.send(f"‚ö†Ô∏è {ctx.author.mention}, already registered with: {user_links[ctx.author.id]}")
        return
    if is_blacklisted(ctx.author.id):
        await ctx.send("‚ùå You are blacklisted and cannot register.")
        return

    user_links[ctx.author.id] = link
    db_upsert_user(ctx.author.id, link)
    user_stats.setdefault(ctx.author.id, {"registrations": 0, "wins": 0})
    user_stats[ctx.author.id]["registrations"] += 1
    db_update_stat(ctx.author.id, delta_reg=1)
    await ctx.send(f"‚úÖ {ctx.author.mention}, your X link has been registered: {link}")

@bot.command()
async def unregister(ctx, member: discord.Member = None):
    """
    Unregister yourself, or (if admin) unregister another member.
    """
    # Decide target user
    target = member or ctx.author

    # Check if user is in DB
    conn = db_conn()
    c = conn.cursor()
    c.execute("SELECT 1 FROM users WHERE user_id = ?", (target.id,))
    exists = c.fetchone()
    conn.close()

    if not exists:
        if target == ctx.author:
            await ctx.send(f"‚ö†Ô∏è {ctx.author.mention}, you are not registered.")
        else:
            await ctx.send(f"‚ö†Ô∏è {target.mention} is not registered.")
        return

    # Admin-only if unregistering someone else
    if member and not ctx.author.guild_permissions.administrator:
        await ctx.send("‚ùå You don‚Äôt have permission to unregister other users.")
        return

    # Remove from memory
    user_links.pop(target.id, None)
    already_picked.discard(target.id)
    always_pick.discard(target.id)
    user_stats.pop(target.id, None)

    # Remove from DB
    conn = db_conn()
    c = conn.cursor()
    c.execute("DELETE FROM users WHERE user_id = ?", (target.id,))
    c.execute("DELETE FROM stats WHERE user_id = ?", (target.id,))
    c.execute("DELETE FROM always_pick WHERE user_id = ?", (target.id,))
    c.execute("DELETE FROM raffle_winners WHERE user_id = ?", (target.id,))
    c.execute("DELETE FROM picks_state WHERE user_id = ?", (target.id,))
    conn.commit()
    conn.close()

    if target == ctx.author:
        await ctx.send(f"‚úÖ {ctx.author.mention}, you have been unregistered successfully.")
    else:
        await ctx.send(f"‚úÖ {target.mention} has been unregistered by {ctx.author.mention}.")

@bot.command()
@commands.has_permissions(administrator=True)
async def blacklist(ctx, member: discord.Member):
    """Blacklist a user (they cannot register or be picked)."""
    # Delete the command message
    try:
        await ctx.message.delete()
    except discord.Forbidden:
        pass  # Bot might not have Manage Messages permission
    except discord.HTTPException:
        pass

    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT OR IGNORE INTO blacklist(user_id) VALUES(?)", (member.id,))
        con.commit()

    await ctx.send(f"üö´ {member.mention} has been blacklisted.")

@bot.command()
@commands.has_permissions(administrator=True)
async def unblacklist(ctx, member: discord.Member):
    """Remove a user from the blacklist."""
    # Delete the command message
    try:
        await ctx.message.delete()
    except discord.Forbidden:
        pass
    except discord.HTTPException:
        pass

    with db_conn() as con:
        cur = con.cursor()
        cur.execute("DELETE FROM blacklist WHERE user_id=?", (member.id,))
        con.commit()

    await ctx.send(f"‚úÖ {member.mention} removed from blacklist.")

@bot.command(name="blacklist_list")
@commands.has_permissions(administrator=True)
async def blacklist_list(ctx):
    """Show all blacklisted users."""
 # Delete the invoking message
    try:
        await ctx.message.delete()
    except discord.Forbidden:
        pass
    except discord.HTTPException:
        pass
    with db_conn() as con:
        cur = con.cursor()
        rows = cur.execute("SELECT user_id FROM blacklist").fetchall()

    if not rows:
        await ctx.send("‚úÖ No users are currently blacklisted.")
        return

    members = []
    for (uid,) in rows:
        member = ctx.guild.get_member(uid)
        if member:
            members.append(member.mention)
        else:
            members.append(f"<@{uid}> (not in server)")

    # Build embed
    embed = discord.Embed(
        title="üö´ Blacklisted Users",
        description="\n".join(members),
        color=discord.Color.dark_red()
    )
    embed.set_footer(text=f"Total: {len(members)} users")

    await ctx.send(embed=embed)

@bot.command()
@commands.has_permissions(administrator=True)
async def list_users(ctx):
    """List registered users by tagging them (split across embeds if too long)."""
 # Delete the invoking message
    try:
        await ctx.message.delete()
    except discord.Forbidden:
        pass
    except discord.HTTPException:
        pass
    if not user_links:
        await ctx.send("‚ö†Ô∏è No users registered yet.")
        return

    online, offline = [], []
    for uid in user_links.keys():
        member = ctx.guild.get_member(uid)
        if not member:
            continue
        if member.status != discord.Status.offline:
            online.append(member.mention)
        else:
            offline.append(member.mention)

    def make_embed(batch, title, online_count, offline_count):
        embed = discord.Embed(
            title=title,
            description="\n".join(batch),
            color=discord.Color.green() if "Online" in title else discord.Color.red()
        )
        embed.set_footer(
            text=f"Online: {online_count} | Offline: {offline_count} | Total: {len(user_links)}"
        )
        return embed

    # Send online users in batches
    batch, total_chars, batch_num = [], 0, 1
    for user in online:
        if total_chars + len(user) > 5500:
            await ctx.send(embed=make_embed(batch, f"üü¢ Online Users (Batch {batch_num})", len(online), len(offline)))
            batch, total_chars = [], 0
            batch_num += 1
        batch.append(user)
        total_chars += len(user)
    if batch:
        await ctx.send(embed=make_embed(batch, f"üü¢ Online Users (Batch {batch_num})", len(online), len(offline)))

    # Send offline users in batches
    batch, total_chars, batch_num = [], 0, 1
    for user in offline:
        if total_chars + len(user) > 5500:
            await ctx.send(embed=make_embed(batch, f"üî¥ Offline Users (Batch {batch_num})", len(online), len(offline)))
            batch, total_chars = [], 0
            batch_num += 1
        batch.append(user)
        total_chars += len(user)
    if batch:
        await ctx.send(embed=make_embed(batch, f"üî¥ Offline Users (Batch {batch_num})", len(online), len(offline)))

@bot.command()
@commands.has_permissions(administrator=True)
async def pick(ctx, raffle_name: str, number: int):
    """Pick winners for a space. Always-pick users always win, blacklist excluded."""
 # Delete the invoking message
    try:
        await ctx.message.delete()
    except discord.Forbidden:
        pass
    except discord.HTTPException:
        pass
    global already_picked

    # 1. Always-pick users (priority winners, unless blacklisted)
    priority_winners = [
        m for uid in always_pick
        if (m := ctx.guild.get_member(uid))
        and uid not in already_picked
        and not is_blacklisted(uid)   # ‚úÖ skip blacklisted
    ]

    # 2. Normal eligible users (online only, not already picked, not blacklisted)
    eligible = [
        m for uid in user_links
        if (m := ctx.guild.get_member(uid))
        and uid not in already_picked
        and m.status == discord.Status.online
        and uid not in always_pick
        and not is_blacklisted(uid)   # ‚úÖ skip blacklisted
    ]

    winners = []

    # Always-pick winners first
    if priority_winners:
        winners.extend(priority_winners)
        number -= len(priority_winners)

    # Fill remaining slots randomly from eligible users
    if number > 0 and eligible:
        winners.extend(random.sample(eligible, min(number, len(eligible))))

    if not winners:
        await ctx.send("‚ö†Ô∏è No eligible users available for this space.")
        return

    # üîÄ Shuffle final list so always-picks aren‚Äôt obvious
    random.shuffle(winners)

    # Save results
    raffles.setdefault(raffle_name, [])
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT OR IGNORE INTO raffles(raffle_name) VALUES(?)", (raffle_name,))
        con.commit()

    winner_role = discord.utils.get(ctx.guild.roles, name=WINNER_ROLE_NAME)
    if not winner_role:
        winner_role = await ctx.guild.create_role(name=WINNER_ROLE_NAME)

    # Build winners table
    table = "```\nS/N | Discord Name         | X Username\n" + "-" * 40 + "\n"
    for idx, w in enumerate(winners, start=1):
        already_picked.add(w.id)
        raffles[raffle_name].append(w.id)

        with db_conn() as con:
            cur = con.cursor()
            cur.execute("INSERT OR IGNORE INTO raffle_winners(raffle_name, user_id) VALUES(?, ?)", (raffle_name, w.id))
            cur.execute("INSERT OR IGNORE INTO stats(user_id, registrations, wins) VALUES(?, 0, 0)", (w.id,))
            cur.execute("UPDATE stats SET wins = wins + 1 WHERE user_id=?", (w.id,))
            con.commit()

        user_stats.setdefault(w.id, {"registrations": 0, "wins": 0})
        user_stats[w.id]["wins"] += 1

        await w.add_roles(winner_role)

        x_link = user_links.get(w.id, "")
        username = x_link.split("/")[-1] if x_link else "-"
        table += f"{idx:<3} | {w.display_name:<20} | {username}\n"
    table += "```"

    embed = discord.Embed(
        title=f"üéâ Winners - {raffle_name} (Space)",
        description=table,
        color=discord.Color.gold()
    )

    await ctx.send(embed=embed)



@bot.command()
@commands.has_permissions(administrator=True)
async def reset_picks(ctx):
    # NEW BEHAVIOR: reset includes always-pick users as available again
 # Delete the invoking message
    try:
        await ctx.message.delete()
    except discord.Forbidden:
        pass
    except discord.HTTPException:
        pass
    global already_picked
    already_picked.clear()
    db_reset_picks(clear_all=True)
    await ctx.send("‚úÖ Picks reset. All users are available for the next space.")

@bot.command()
@commands.has_permissions(administrator=True)
async def status(ctx):
    """Show bot status"""
    total = len(user_links)
    online = [uid for uid in user_links if (m := ctx.guild.get_member(uid)) and m.status != discord.Status.offline]
    offline = [uid for uid in user_links if uid not in online]

# üî• Count blacklisted users (already returns an integer)
    with db_conn() as con:
        cur = con.cursor()
        total_blacklisted = cur.execute("SELECT COUNT(*) FROM blacklist").fetchone()[0]

    embed = discord.Embed(title="üìä Bot Status", color=discord.Color.green())
    embed.add_field(name="üìù Registered", value=total)
    embed.add_field(name="üü¢ Online", value=len(online))
    embed.add_field(name="üî¥ Offline", value=len(offline))
    embed.add_field(name="üèÜ Already Picked", value=len(already_picked))
    embed.add_field(name="üö´ Blacklisted Users",value=total_blacklisted)
    await ctx.send(embed=embed, reference=ctx.message, mention_author=True)

# -------------------------
# üÜï Profile Command (+ Show Wins button)
# -------------------------
class ShowWinsView(View):
    def __init__(self, user_id: int):
        super().__init__(timeout=120)
        self.user_id = user_id
        self.add_item(Button(label="Show Wins", style=discord.ButtonStyle.primary, custom_id=f"show_wins:{user_id}"))

    @discord.ui.button(label="Show Wins", style=discord.ButtonStyle.primary)
    async def _dummy(self, *args, **kwargs):
        pass  # placeholder (required by decorator, but we'll handle via interaction_check)

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        # serve wins for the stored user
        if interaction.user.id != self.user_id and not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("You can only view your own wins.", ephemeral=True)
            return False
        wins = db_user_wins(self.user_id)
        if wins:
            lines = "\n".join(f"‚Ä¢ {name}" for name in wins)
        else:
            lines = "No wins yet."
        embed = discord.Embed(title="üèÜ Your Space Wins", description=lines, color=discord.Color.purple())
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return True

@bot.command()
async def profile(ctx, member: discord.Member = None):
    """Show gamified profile"""
    user = member or ctx.author
    link = user_links.get(user.id, "Not registered")
    stats = user_stats.get(user.id, {"registrations": 0, "wins": 0})
    wins = stats["wins"]

    ranks = [
        (0, 5, "üå± Newbie", "üå±"),
        (6, 10, "üéØ Amateur", "üéØ"),
        (11, 15, "üõ°Ô∏è Experienced", "üõ°Ô∏è"),
        (16, 20, "‚ö° Skilled", "‚ö°"),
        (21, 25, "üî• Advanced", "üî•"),
        (26, 30, "üèÜ Pro", "üèÜ"),
        (31, float("inf"), "üëë Legend", "üëë"),
    ]

    rank_name, rank_emoji, progress = "Unranked", "‚ùî", 0
    for lower, upper, name, emoji in ranks:
        if lower <= wins <= upper:
            rank_name, rank_emoji = name, emoji
            next_threshold = upper if upper != float("inf") else None
            progress = 10 if not next_threshold else int((wins - lower) / (upper - lower + 1) * 10)
            break

    bar = "‚ñ†" * progress + "‚ñ°" * (10 - progress)
    percent = int(progress * 10)

    embed = discord.Embed(color=discord.Color.blue())
    embed.set_author(name=f"{user.display_name}'s Profile", icon_url=user.display_avatar.url)
    embed.description = (
        f"üë§ Profile: {user.mention}\n"
        f"üåê X Link: {link}\n\n"
        f"üìä Stats:\n"
        f"- üìù Registrations: {stats['registrations']}\n"
        f"- üèÜ Wins: {wins}\n\n"
        f"üéñÔ∏è Rank: {rank_emoji} {rank_name}\n"
        f"üîã Progress: [{bar}] {percent}%"
    )

    view = ShowWinsView(user.id)
    await ctx.send(embed=embed, view=view, reference=ctx.message, mention_author=True)

# -------------------------
# üéØ Always-pick (UNCHANGED commands; now persisted)
# -------------------------
@bot.command()
@commands.has_permissions(administrator=True)
async def always_add(ctx, member: discord.Member):
    always_pick.add(member.id)
    db_set_always(member.id, add=True)
    await ctx.send(f"‚úÖ {member.mention} added to always-pick list.")

@bot.command()
@commands.has_permissions(administrator=True)
async def always_remove(ctx, member: discord.Member):
    always_pick.discard(member.id)
    db_set_always(member.id, add=False)
    await ctx.send(f"‚ùå {member.mention} removed.")

@bot.command()
@commands.has_permissions(administrator=True)
async def always_list(ctx):
    if not always_pick:
        await ctx.send("‚ö†Ô∏è No users in always-pick list.")
        return
    members = [ctx.guild.get_member(uid).mention for uid in always_pick if ctx.guild.get_member(uid)]
    await ctx.send("üëë Always-pick list:\n" + ", ".join(members))

# -------------------------
# üì§ Export helpers
# -------------------------
def build_rows_for_raffle(guild: discord.Guild, raffle_name: str):
    rows = [["S/N", "Discord Name", "X Username", "X Link"]]
    # winners for this space (works for active or archived since we read db if needed)
    winners = []
    if raffle_name in raffles:
        winners = raffles.get(raffle_name, [])
    else:
        # pull from DB if archived (keeps working post-archive)
        with db_conn() as con:
            cur = con.cursor()
            winners = [r[0] for r in cur.execute(
                "SELECT user_id FROM raffle_winners WHERE raffle_name=? ORDER BY picked_at ASC", (raffle_name,)
            )]

    for sn, uid in enumerate(winners, start=1):
        member = guild.get_member(uid)
        display = member.display_name if member else f"User {uid}"
        x_link = user_links.get(uid, "")
        username = x_link.split("/")[-1] if x_link else "-"
        rows.append([sn, display, username, x_link])
    return rows

def export_excel(guild: discord.Guild, raffle_name: str) -> str:
    rows = build_rows_for_raffle(guild, raffle_name)
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = raffle_name[:31] if raffle_name else "Sheet1"  # Excel limit
    for r in rows:
        ws.append(r)
    file_path = f"{raffle_name}_winners.xlsx"
    wb.save(file_path)
    return file_path

def export_pdf(guild: discord.Guild, raffle_name: str) -> str:
    rows = build_rows_for_raffle(guild, raffle_name)
    file_path = f"{raffle_name}_winners.pdf"
    doc = SimpleDocTemplate(file_path, pagesize=A4, title=f"{raffle_name} Winners")
    styles = getSampleStyleSheet()
    elements = []
    elements.append(Paragraph(f"üéâ Winners - {raffle_name} (Space)", styles['Title']))
    elements.append(Spacer(1, 12))
    table = Table(rows, repeatRows=1)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0,0), (-1,0), colors.gold),
        ('TEXTCOLOR', (0,0), (-1,0), colors.black),
        ('GRID', (0,0), (-1,-1), 0.5, colors.grey),
        ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold'),
        ('ALIGN', (0,0), (-1,-1), 'LEFT'),
        ('ROWBACKGROUNDS', (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
    ]))
    elements.append(table)
    doc.build(elements)
    return file_path

def export_png(guild: discord.Guild, raffle_name: str) -> str:
    if not PIL_AVAILABLE:
        raise RuntimeError("Pillow not installed; PNG export unavailable.")
    rows = build_rows_for_raffle(guild, raffle_name)
    # simple table render
    col_widths = [60, 260, 200, 420]
    padding = 12
    row_h = 36
    width = sum(col_widths) + padding*2
    height = row_h * (len(rows)+1) + padding*2
    img = Image.new("RGB", (width, height), "white")
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("arial.ttf", 18)
        font_b = ImageFont.truetype("arial.ttf", 20)
    except Exception:
        font = ImageFont.load_default()
        font_b = font
    y = padding
    # Title
    draw.text((padding, y), f"Winners - {raffle_name} (Space)", font=font_b, fill="black")
    y += row_h
    x = padding
    # Header bg
    draw.rectangle([x, y, width-padding, y+row_h], outline="black", fill="#ffd166")
    # draw header
    headers = rows[0]
    cx = x
    for i, head in enumerate(headers):
        draw.text((cx+8, y+8), str(head), font=font_b, fill="black")
        cx += col_widths[i]
        draw.line([(cx, y), (cx, y+row_h)], fill="black", width=1)
    draw.rectangle([x, y, width-padding, y+row_h], outline="black", width=1)
    y += row_h
    # body
    for r in rows[1:]:
        cx = x
        for i, cell in enumerate(r):
            draw.text((cx+8, y+8), str(cell), font=font, fill="black")
            cx += col_widths[i]
            draw.line([(cx, y), (cx, y+row_h)], fill="#888888", width=1)
        draw.rectangle([x, y, width-padding, y+row_h], outline="#888888", width=1)
        y += row_h
    file_path = f"{raffle_name}_winners.png"
    img.save(file_path)
    return file_path

# -------------------------
# üì¶ Export UI (with permissions + scheduled archive)
# -------------------------
async def schedule_archive_in_5(raffle_name: str):
    # Schedule archive (persist to DB so it survives restarts)
    when = datetime.utcnow() + timedelta(minutes=5)
    db_schedule_archive(raffle_name, when)

class ExportButtons(View):
    def __init__(self, raffle_name: str, guild: discord.Guild, archived: bool = False):
        super().__init__(timeout=180)
        self.raffle_name = raffle_name
        self.guild = guild
        self.archived = archived
        # Buttons are created via decorators below; the add_item calls are not needed here.

    @discord.ui.button(label="Export PNG (visible to all)", style=discord.ButtonStyle.secondary, custom_id="exp_png")
    async def _png(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self._handle_export(interaction, "png")

    @discord.ui.button(label="Export EXCEL (admin only)", style=discord.ButtonStyle.success, custom_id="exp_xlsx")
    async def _xlsx(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("‚ùå Only admins can export Excel.", ephemeral=True)
            return
        await self._handle_export(interaction, "xlsx")

    @discord.ui.button(label="Export PDF (visible to all)", style=discord.ButtonStyle.danger, custom_id="exp_pdf")
    async def _pdf(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self._handle_export(interaction, "pdf")

    async def _handle_export(self, interaction: discord.Interaction, fmt: str):
        # Determine if we have any winners
        has_winners = False
        if self.raffle_name in raffles:
            has_winners = len(raffles.get(self.raffle_name, [])) > 0
        else:
            # Check DB for archived spaces
            with db_conn() as con:
                cur = con.cursor()
                row = cur.execute("SELECT COUNT(*) FROM raffle_winners WHERE raffle_name=?", (self.raffle_name,)).fetchone()
                has_winners = row and row[0] > 0

        if not has_winners:
            await interaction.response.send_message(f"‚ö†Ô∏è No winners found in **{self.raffle_name}**.", ephemeral=True)
            return

        try:
            if fmt == "xlsx":
                path = export_excel(self.guild, self.raffle_name)
                # Excel is admin-only and **ephemeral** to the admin
                await interaction.response.send_message(file=discord.File(path), ephemeral=True)
            elif fmt == "pdf":
                path = export_pdf(self.guild, self.raffle_name)
                # PDF posted **to the channel** (visible to all)
                await interaction.channel.send(file=discord.File(path), content=f"üìÑ PDF export for **{self.raffle_name}** (Space)")
                await interaction.response.send_message("‚úÖ PDF exported.", ephemeral=True)
            elif fmt == "png":
                path = export_png(self.guild, self.raffle_name)
                # PNG posted **to the channel** (visible to all)
                await interaction.channel.send(file=discord.File(path), content=f"üñºÔ∏è PNG export for **{self.raffle_name}** (Space)")
                await interaction.response.send_message("‚úÖ PNG exported.", ephemeral=True)
            else:
                await interaction.response.send_message("Unknown export format.", ephemeral=True)
                return
        finally:
            try:
                os.remove(path)
            except Exception:
                pass

        # Schedule archive (5 minutes after any export)
        await schedule_archive_in_5(self.raffle_name)

class RaffleSelect(Select):
    def __init__(self, options, archived: bool = False):
        placeholder = "Select a space to export..." if not archived else "Select an archived space..."
        super().__init__(placeholder=placeholder, min_values=1, max_values=1, options=options)
        self.archived = archived

    async def callback(self, interaction: discord.Interaction):
        raffle_name = self.values[0]
        # Validate winners exist (active or archived)
        has_any = False
        if not self.archived:
            winners = raffles.get(raffle_name, [])
            has_any = bool(winners)
        else:
            # archived ‚Äî check DB
            with db_conn() as con:
                cur = con.cursor()
                row = cur.execute("SELECT COUNT(*) FROM raffle_winners WHERE raffle_name=?", (raffle_name,)).fetchone()
                has_any = row and row[0] > 0

        if not has_any:
            await interaction.response.send_message(f"‚ö†Ô∏è No winners in **{raffle_name}**.", ephemeral=True)
            return

        view = ExportButtons(raffle_name, interaction.guild, archived=self.archived)
        title = "üì§ Export options for archived space" if self.archived else "üì§ Export options for space"
        await interaction.response.send_message(f"{title} **{raffle_name}**:", view=view, ephemeral=True)

class RaffleDropdown(View):
    def __init__(self, archived: bool = False):
        super().__init__(timeout=180)
        if not archived:
            names = db_get_active_raffles()
        else:
            names = db_get_archived_raffles()
        if not names:
            # add a disabled dummy to show "none"
            opts = [discord.SelectOption(label="(none)", description="No spaces available", default=True)]
        else:
            opts = [discord.SelectOption(label=name, description=("Export " + name)) for name in names]
        self.add_item(RaffleSelect(opts, archived=archived))

# -------------------------
# üì§ Commands: Export & Archive
# -------------------------
@bot.command()
async def export(ctx):
    """
    Show export UI for active spaces.
    Visible to everyone. Buttons enforce:
      - PNG/PDF: anyone can export (posted to channel).
      - Excel: admin-only (ephemeral to admin).
    """
    active = db_get_active_raffles()
    if not active:
        await ctx.send("‚ö†Ô∏è No active spaces available.")
        return
    embed = discord.Embed(
        title="üì§ Export Winners (Spaces)",
        description="Select a **space** to export, then choose **PNG / EXCEL / PDF**.\n"
                    "- PNG/PDF: visible to everyone in the channel.\n"
                    "- Excel: admin-only (you‚Äôll get it ephemerally).",
        color=discord.Color.gold()
    )
    await ctx.send(embed=embed, view=RaffleDropdown(archived=False))

@bot.command(name="archive")
async def list_archived(ctx):
    """
    Show archived spaces and allow exporting them (PNG/PDF for all, Excel admin-only).
    """
    archived = db_get_archived_raffles()
    if not archived:
        await ctx.send("üì¶ No archived spaces yet.")
        return
    embed = discord.Embed(
        title="üì¶ Archived Spaces",
        description="Select an **archived space** to export its winners.",
        color=discord.Color.blurple()
    )
    await ctx.send(embed=embed, view=RaffleDropdown(archived=True))
@bot.command()
@commands.has_permissions(administrator=True)
async def reset_db(ctx):
    """‚ö†Ô∏è Clears all tables in the database."""
    conn = db_conn()   # <-- use your actual DB connection function name
    c = conn.cursor()
    c.execute("DELETE FROM users")
    c.execute("DELETE FROM raffles")
    c.execute("DELETE FROM stats")
    conn.commit()
    conn.close()

    global user_links, raffles, user_stats, already_picked, always_pick
    user_links.clear()
    raffles.clear()
    user_stats.clear()
    already_picked.clear()
    always_pick.clear()

    await ctx.send("‚úÖ Database has been reset (all users, raffles, stats cleared).")

@bot.command()
@commands.has_permissions(administrator=True)
async def reset_raffles(ctx):
    """‚ö†Ô∏è Clears raffles and stats, but keeps registered users."""
    conn = db_conn()   # or db_conn() if that‚Äôs your function name
    c = conn.cursor()
    c.execute("DELETE FROM raffles")
    c.execute("DELETE FROM stats")
    conn.commit()
    conn.close()

    global raffles, user_stats, already_picked
    raffles.clear()
    user_stats.clear()
    already_picked.clear()

    await ctx.send("‚úÖ Raffles and stats have been reset. Registered users remain.")

# -------------------------
# ‚ñ∂Ô∏è Run Bot (UNCHANGED)
# -------------------------
bot.run(TOKEN)
