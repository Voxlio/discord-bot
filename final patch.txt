import os
import re
import random
import sqlite3
import asyncio
from datetime import datetime, timedelta
import discord
from discord.ext import commands, tasks
from discord.ui import View, Select, Button, Modal, TextInput
from io import BytesIO
import openpyxl
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
import time

# cooldown tracker for VOX earning
last_message_time = {} # {user_id: timestamp}

# Optional PNG export (pure-Pillow)
try:
    from PIL import Image, ImageDraw, ImageFont
    PIL_AVAILABLE = True
except Exception:
    PIL_AVAILABLE = False

# -------------------------
# üîë Tokens & Logo
# -------------------------
# IMPORTANT: rotate token in Discord Developer Portal and set DISCORD_TOKEN env var
TOKEN = "MTQxMjg5MzU1NzI2OTcyNTMxNQ.GZJbok.b2aYEGrnk_hiAWyr5Nkd66GSRBm05Jg4RL0wm4"

if not TOKEN:
    raise RuntimeError("DISCORD_TOKEN environment variable not set. Rotate your token and set DISCORD_TOKEN.")

LOGO_URL = "https://cdn.discordapp.com/attachments/993192595796787200/1413250033545121802/vox_logo.png"

# -------------------------
# ‚öôÔ∏è Bot Setup
# -------------------------
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.presences = True
bot = commands.Bot(command_prefix="!", intents=intents)

# -------------------------
# üì¶ Storage (backed by DB)
# -------------------------
user_links = {}     # {user_id: "https://x.com/..."}
# unified stats shape across the bot
user_stats = {}     # {user_id: {"registrations": int, "wins": int, "vox": int, "tickets_total": int, "tickets_available": int, "tickets_used": int, "tickets_committed": int}}
raffles = {}        # {raffle_name: [user_id, user_id]}
already_picked = set()
always_pick = set()
WINNER_ROLE_NAME = "Winner"

# Ticket system defaults (configurable via command)
TICKET_PRICE = 10  # default price in $VOX (admins can change)

DB_PATH = "voxpicker.db"

# -------------------------
# üóÉÔ∏è Database helpers
# -------------------------
def db_conn():
    return sqlite3.connect(DB_PATH)

def db_init():
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("""
        CREATE TABLE IF NOT EXISTS users(
            user_id INTEGER PRIMARY KEY,
            x_link TEXT
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS stats(
            user_id INTEGER PRIMARY KEY,
            registrations INTEGER DEFAULT 0,
            wins INTEGER DEFAULT 0,
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS currency(
            user_id INTEGER PRIMARY KEY,
            vox INTEGER DEFAULT 0,
            tickets_total INTEGER DEFAULT 0,
            tickets_available INTEGER DEFAULT 0,
            tickets_used INTEGER DEFAULT 0,
            tickets_committed INTEGER DEFAULT 0
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS always_pick(
            user_id INTEGER PRIMARY KEY
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS raffles(
            raffle_name TEXT,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            archived INTEGER DEFAULT 0,
            PRIMARY KEY(raffle_name)
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS raffle_winners(
            raffle_name TEXT,
            user_id INTEGER,
            picked_at TEXT DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY(raffle_name, user_id),
            FOREIGN KEY(raffle_name) REFERENCES raffles(raffle_name)
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS picks_state(
            user_id INTEGER PRIMARY KEY
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS archive_schedule(
            raffle_name TEXT PRIMARY KEY,
            archive_at TEXT
        );
        """)
        # New blacklist table
        cur.execute("""
        CREATE TABLE IF NOT EXISTS blacklist(
            user_id INTEGER PRIMARY KEY
        );
        """)
        con.commit()

def load_state_from_db():
    # Clear in-memory state before loading
    user_links.clear()
    user_stats.clear()
    raffles.clear()
    already_picked.clear()
    always_pick.clear()

    with db_conn() as con:
        cur = con.cursor()
        
        # 1. Load users and initialize a base stats dictionary for each
        for uid, link in cur.execute("SELECT user_id, x_link FROM users"):
            user_links[uid] = link or ""
            user_stats[uid] = {
                "registrations": 0,
                "wins": 0,
                "vox": 0,
                "tickets_total": 0,
                "tickets_available": 0,
                "tickets_used": 0,
                "tickets_committed": 0
            }

        # 2. Overwrite defaults with data from the 'stats' table
        for uid, reg, wins in cur.execute("SELECT user_id, registrations, wins FROM stats"):
            if uid in user_stats:
                user_stats[uid].update({"registrations": reg or 0, "wins": wins or 0})
        
        # 3. Overwrite defaults with data from the 'currency' table
        for uid, vox, total, available, used, committed in cur.execute("SELECT * FROM currency"):
            if uid in user_stats:
                user_stats[uid].update({
                    "vox": vox or 0,
                    "tickets_total": total or 0,
                    "tickets_available": available or 0,
                    "tickets_used": used or 0,
                    "tickets_committed": committed or 0
                })
        
        # 4. Load other state as before
        for (uid,) in cur.execute("SELECT user_id FROM always_pick"):
            always_pick.add(uid)

        for (name,) in cur.execute("SELECT raffle_name FROM raffles WHERE archived = 0"):
            raffles[name] = []
        
        for name, uid in cur.execute("""
            SELECT raffle_name, user_id FROM raffle_winners
            JOIN raffles USING(raffle_name)
            WHERE raffles.archived = 0
        """):
            raffles.setdefault(name, []).append(uid)
        
        for (uid,) in cur.execute("SELECT user_id FROM picks_state"):
            already_picked.add(uid)

def db_upsert_user(user_id: int, link: str):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT INTO users(user_id, x_link) VALUES(?, ?) ON CONFLICT(user_id) DO UPDATE SET x_link=excluded.x_link", (user_id, link))
        cur.execute("INSERT INTO stats(user_id, registrations, wins) VALUES(?, 0, 0) ON CONFLICT(user_id) DO NOTHING", (user_id,))
        cur.execute("INSERT INTO currency(user_id) VALUES(?) ON CONFLICT(user_id) DO NOTHING", (user_id,))
        con.commit()

def db_update_stat(user_id: int, delta_reg: int = 0, delta_wins: int = 0):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("""
        INSERT INTO stats(user_id, registrations, wins) VALUES(?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
            registrations = registrations + ?,
            wins = wins + ?
        """, (user_id, max(delta_reg,0), max(delta_wins,0), delta_reg, delta_wins))
        con.commit()

def db_update_currency(user_id: int, delta_vox: int = 0, delta_total: int = 0, delta_available: int = 0, delta_used: int = 0, delta_committed: int = 0):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("""
        INSERT INTO currency(user_id, vox, tickets_total, tickets_available, tickets_used, tickets_committed)
        VALUES(?, ?, ?, ?, ?, ?) ON CONFLICT(user_id) DO UPDATE SET
            vox = vox + ?,
            tickets_total = tickets_total + ?,
            tickets_available = tickets_available + ?,
            tickets_used = tickets_used + ?,
            tickets_committed = tickets_committed + ?
        """, (
            user_id, max(delta_vox, 0), max(delta_total, 0), max(delta_available, 0), max(delta_used, 0), max(delta_committed, 0),
            delta_vox, delta_total, delta_available, delta_used, delta_committed
        ))
        con.commit()

def db_set_always(user_id: int, add=True):
    with db_conn() as con:
        cur = con.cursor()
        if add:
            cur.execute("INSERT OR IGNORE INTO always_pick(user_id) VALUES(?)", (user_id,))
        else:
            cur.execute("DELETE FROM always_pick WHERE user_id=?", (user_id,))
        con.commit()

def db_set_picked(user_id: int, add=True):
    with db_conn() as con:
        cur = con.cursor()
        if add:
            cur.execute("INSERT OR IGNORE INTO picks_state(user_id) VALUES(?)", (user_id,))
        else:
            cur.execute("DELETE FROM picks_state WHERE user_id=?", (user_id,))
        con.commit()

def db_reset_picks(clear_all=True):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("DELETE FROM picks_state")
        con.commit()

def db_create_raffle(raffle_name: str):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT OR IGNORE INTO raffles(raffle_name, archived) VALUES(?, 0)", (raffle_name,))
        con.commit()

def db_add_winner(raffle_name: str, user_id: int):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT OR IGNORE INTO raffle_winners(raffle_name, user_id, picked_at) VALUES(?, ?, ?)",
                     (raffle_name, user_id, datetime.utcnow().isoformat()))
        con.commit()

def db_archive_raffle(raffle_name: str):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("UPDATE raffles SET archived = 1 WHERE raffle_name = ?", (raffle_name,))
        cur.execute("DELETE FROM archive_schedule WHERE raffle_name=?", (raffle_name,))
        con.commit()

def db_is_archived(raffle_name: str) -> bool:
    with db_conn() as con:
        cur = con.cursor()
        row = cur.execute("SELECT archived FROM raffles WHERE raffle_name=?", (raffle_name,)).fetchone()
        return bool(row and row[0] == 1)

def db_get_active_raffles():
    with db_conn() as con:
        cur = con.cursor()
        return [r[0] for r in cur.execute("SELECT raffle_name FROM raffles WHERE archived = 0")]

def db_get_archived_raffles():
    with db_conn() as con:
        cur = con.cursor()
        return [r[0] for r in cur.execute("SELECT raffle_name FROM raffles WHERE archived = 1")]

def db_schedule_archive(raffle_name: str, when: datetime):
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT OR REPLACE INTO archive_schedule(raffle_name, archive_at) VALUES(?, ?)",
                     (raffle_name, when.isoformat()))
        con.commit()

def db_get_due_archives(now: datetime):
    with db_conn() as con:
        cur = con.cursor()
        return [r[0] for r in cur.execute("SELECT raffle_name FROM archive_schedule WHERE archive_at <= ?", (now.isoformat(),))]

def db_user_wins(user_id: int):
    with db_conn() as con:
        cur = con.cursor()
        return [row[0] for row in cur.execute("""
            SELECT raffle_name FROM raffle_winners
            JOIN raffles USING(raffle_name)
            WHERE user_id=?""", (user_id,))]

def is_blacklisted(user_id: int) -> bool:
    with db_conn() as con:
        cur = con.cursor()
        row = cur.execute("SELECT 1 FROM blacklist WHERE user_id=?", (user_id,)).fetchone()
        return row is not None

# -------------------------
# ‚è±Ô∏è Background: handle scheduled archives
# -------------------------
@tasks.loop(seconds=30.0)
async def archive_watcher():
    now = datetime.utcnow()
    due = db_get_due_archives(now)
    if not due:
        return
    for name in due:
        db_archive_raffle(name)
        raffles.pop(name, None)

@archive_watcher.before_loop
async def before_archive_watcher():
    await bot.wait_until_ready()

# -------------------------
# üöÄ Events
# -------------------------
@bot.event
async def on_ready():
    db_init()
    load_state_from_db()
    archive_watcher.start()
    print(f"‚úÖ Bot is online as {bot.user}")

# -------------------------
# üìù Commands
# -------------------------
@bot.command()
async def hello(ctx):
    await ctx.send(f"Hello {ctx.author.mention}! üëã")

@bot.command()
async def register(ctx, link: str = None):
    """Register your X (Twitter) link"""
    if not link:
        await ctx.send("‚ö†Ô∏è Please provide your X profile link. Example: `!register https://x.com/username`")
        return
    pattern = r"^https:\/\/(x\.com|twitter\.com)\/[A-Za-z0-9_]+$"
    if not re.match(pattern, link):
        await ctx.send("‚ùå Invalid link! Example: `https://x.com/username`")
        return
    if is_blacklisted(ctx.author.id):
        await ctx.send("‚ùå You are blacklisted and cannot register.")
        return
    if ctx.author.id in user_links:
        await ctx.send(f"‚ö†Ô∏è {ctx.author.mention}, already registered with: {user_links[ctx.author.id]}")
        return

    user_links[ctx.author.id] = link
    db_upsert_user(ctx.author.id, link)
    # ensure unified stats keys
    user_stats.setdefault(ctx.author.id, {
        "registrations": 0, "wins": 0, "vox": 0,
        "tickets_total": 0, "tickets_available": 0, "tickets_used": 0, "tickets_committed": 0
    })
    user_stats[ctx.author.id]["registrations"] += 1
    db_update_stat(ctx.author.id, delta_reg=1)
    await ctx.send(f"‚úÖ {ctx.author.mention}, your X link has been registered: {link}")

@bot.command()
async def unregister(ctx, member: discord.Member = None):
    target = member or ctx.author
    with db_conn() as con:
        cur = con.cursor()
        exists = cur.execute("SELECT 1 FROM users WHERE user_id = ?", (target.id,)).fetchone()

    if not exists:
        if target == ctx.author:
            await ctx.send(f"‚ö†Ô∏è {ctx.author.mention}, you are not registered.")
        else:
            await ctx.send(f"‚ö†Ô∏è {target.mention} is not registered.")
        return

    if member and not ctx.author.guild_permissions.administrator:
        await ctx.send("‚ùå You don‚Äôt have permission to unregister other users.")
        return

    # In-memory cleanup
    user_links.pop(target.id, None)
    already_picked.discard(target.id)
    always_pick.discard(target.id)
    user_stats.pop(target.id, None)

    # Database cleanup
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("DELETE FROM users WHERE user_id = ?", (target.id,))
        cur.execute("DELETE FROM stats WHERE user_id = ?", (target.id,))
        cur.execute("DELETE FROM currency WHERE user_id = ?", (target.id,))
        cur.execute("DELETE FROM always_pick WHERE user_id = ?", (target.id,))
        cur.execute("DELETE FROM raffle_winners WHERE user_id = ?", (target.id,))
        cur.execute("DELETE FROM picks_state WHERE user_id = ?", (target.id,))
        con.commit()

    if target == ctx.author:
        await ctx.send(f"‚úÖ {ctx.author.mention}, you have been unregistered successfully.")
    else:
        await ctx.send(f"‚úÖ {target.mention} has been unregistered by {ctx.author.mention}.")

@bot.command()
@commands.has_permissions(administrator=True)
async def blacklist(ctx, member: discord.Member):
    try:
        await ctx.message.delete()
    except Exception:
        pass
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("INSERT OR IGNORE INTO blacklist(user_id) VALUES(?)", (member.id,))
        con.commit()
    await ctx.send(f"üö´ {member.mention} has been blacklisted.")

@bot.command()
@commands.has_permissions(administrator=True)
async def unblacklist(ctx, member: discord.Member):
    try:
        await ctx.message.delete()
    except Exception:
        pass
    with db_conn() as con:
        cur = con.cursor()
        cur.execute("DELETE FROM blacklist WHERE user_id=?", (member.id,))
        con.commit()
    await ctx.send(f"‚úÖ {member.mention} removed from blacklist.")

@bot.command(name="blacklist_list")
@commands.has_permissions(administrator=True)
async def blacklist_list(ctx):
    try:
        await ctx.message.delete()
    except Exception:
        pass
    with db_conn() as con:
        cur = con.cursor()
        rows = cur.execute("SELECT user_id FROM blacklist").fetchall()

    if not rows:
        await ctx.send("‚úÖ No users are currently blacklisted.")
        return

    members = []
    for (uid,) in rows:
        member = ctx.guild.get_member(uid)
        if member:
            members.append(member.mention)
        else:
            members.append(f"<@{uid}> (not in server)")

    embed = discord.Embed(
        title="üö´ Blacklisted Users",
        description="\n".join(members),
        color=discord.Color.dark_red()
    )
    embed.set_footer(text=f"Total: {len(members)} users")
    await ctx.send(embed=embed)

@bot.command()
@commands.has_permissions(administrator=True)
async def list_users(ctx):
    try:
        await ctx.message.delete()
    except Exception:
        pass
    if not user_links:
        await ctx.send("‚ö†Ô∏è No users registered yet.")
        return

    online, offline = [], []
    for uid in user_links.keys():
        member = ctx.guild.get_member(uid)
        if not member:
            continue
        if member.status != discord.Status.offline:
            online.append(member.mention)
        else:
            offline.append(member.mention)

    def make_embed(batch, title, online_count, offline_count):
        embed = discord.Embed(
            title=title,
            description="\n".join(batch),
            color=discord.Color.green() if "Online" in title else discord.Color.red()
        )
        embed.set_footer(
            text=f"Online: {online_count} | Offline: {offline_count} | Total: {len(user_links)}"
        )
        return embed

    batch, total_chars, batch_num = [], 0, 1
    for user in online:
        if total_chars + len(user) > 5500:
            await ctx.send(embed=make_embed(batch, f"üü¢ Online Users (Batch {batch_num})", len(online), len(offline)))
            batch, total_chars = [], 0
            batch_num += 1
        batch.append(user)
        total_chars += len(user)
    if batch:
        await ctx.send(embed=make_embed(batch, f"üü¢ Online Users (Batch {batch_num})", len(online), len(offline)))

    batch, total_chars, batch_num = [], 0, 1
    for user in offline:
        if total_chars + len(user) > 5500:
            await ctx.send(embed=make_embed(batch, f"üî¥ Offline Users (Batch {batch_num})", len(online), len(offline)))
            batch, total_chars = [], 0
            batch_num += 1
        batch.append(user)
        total_chars += len(user)
    if batch:
        await ctx.send(embed=make_embed(batch, f"üî¥ Offline Users (Batch {batch_num})", len(online), len(offline)))

@bot.command()
@commands.has_permissions(administrator=True)
async def pick(ctx, raffle_name: str, number: int):
    """Pick winners for a space. Always-pick users always win, blacklist excluded."""
    try:
        await ctx.message.delete()
    except Exception:
        pass
    global already_picked

    priority_winners = [
        m for uid in always_pick
        if (m := ctx.guild.get_member(uid))
        and uid not in already_picked
        and not is_blacklisted(uid)
    ]

    eligible_members = [
        m for uid in user_links
        if (m := ctx.guild.get_member(uid))
        and uid not in already_picked
        and m.status != discord.Status.offline
        and uid not in always_pick
        and not is_blacklisted(uid)
    ]

    # Build pool using tickets_committed and regular users
    pool = []
    for m in eligible_members:
        stats = user_stats.setdefault(m.id, {
            "registrations": 0, "wins": 0, "vox": 0,
            "tickets_total": 0, "tickets_available": 0, "tickets_used": 0, "tickets_committed": 0
        })
        tickets = stats.get("tickets_committed", 0)
        if tickets > 0:
            pool.extend([m] * tickets)

    winners = []
    if priority_winners:
        winners.extend(priority_winners)
        remaining_picks = number - len(priority_winners)
    else:
        remaining_picks = number
        
    if remaining_picks > 0:
        unique_winners = set(w.id for w in winners)
        
        # First, try to fill from the ticket pool
        if pool:
            ticket_winners_count = min(remaining_picks, len(pool))
            for _ in range(ticket_winners_count):
                choice = random.choice(pool)
                if choice.id not in unique_winners:
                    winners.append(choice)
                    unique_winners.add(choice.id)
                pool = [p for p in pool if p.id != choice.id]
            remaining_picks = number - len(winners)

        # Then, fill remaining slots from all eligible members (including those without tickets)
        if remaining_picks > 0:
            all_eligible_for_random = [m for m in eligible_members if m.id not in unique_winners]
            if all_eligible_for_random:
                random_winners = random.sample(all_eligible_for_random, min(remaining_picks, len(all_eligible_for_random)))
                winners.extend(random_winners)

    if not winners:
        await ctx.send("‚ö†Ô∏è No eligible users available for this space.")
        return

    random.shuffle(winners)

    raffles.setdefault(raffle_name, [])
    db_create_raffle(raffle_name)

    winner_role = discord.utils.get(ctx.guild.roles, name=WINNER_ROLE_NAME)
    if not winner_role:
        winner_role = await ctx.guild.create_role(name=WINNER_ROLE_NAME)

    table = "```\nS/N | Discord Name         | X Username\n" + "-" * 40 + "\n"
    for idx, w in enumerate(winners, start=1):
        already_picked.add(w.id)
        raffles[raffle_name].append(w.id)
        db_add_winner(raffle_name, w.id)

        stats = user_stats.setdefault(w.id, {
            "registrations": 0, "wins": 0, "vox": 0,
            "tickets_total": 0, "tickets_available": 0, "tickets_used": 0, "tickets_committed": 0
        })
        stats["wins"] += 1
        db_update_stat(w.id, delta_wins=1)
        db_set_picked(w.id, add=True)

        try:
            await w.add_roles(winner_role)
        except Exception:
            pass

        x_link = user_links.get(w.id, "")
        username = x_link.split("/")[-1] if x_link else "-"
        table += f"{idx:<3} | {w.display_name:<20} | {username}\n"
    table += "```"

    embed = discord.Embed(
        title=f"üéâ Winners - {raffle_name} (Space)",
        description=table,
        color=discord.Color.gold()
    )
    await ctx.send(embed=embed)

    # After raffle: move committed to used and reduce available
    for uid, stats in user_stats.items():
        committed = stats.get("tickets_committed", 0)
        if committed > 0:
            stats["tickets_used"] = stats.get("tickets_used", 0) + committed
            stats["tickets_available"] = max(0, stats.get("tickets_available", 0) - committed)
            stats["tickets_committed"] = 0
            db_update_currency(uid, delta_committed=-committed, delta_used=committed, delta_available=-committed)

@bot.command()
@commands.has_permissions(administrator=True)
async def reset_picks(ctx):
    try:
        await ctx.message.delete()
    except Exception:
        pass
    global already_picked
    already_picked.clear()
    db_reset_picks(clear_all=True)
    await ctx.send("‚úÖ Picks reset. All users are available for the next space.")

@bot.command()
@commands.has_permissions(administrator=True)
async def status(ctx):
    total = len(user_links)
    online = [uid for uid in user_links if (m := ctx.guild.get_member(uid)) and m.status != discord.Status.offline]
    offline = [uid for uid in user_links if uid not in online]

    with db_conn() as con:
        cur = con.cursor()
        total_blacklisted = cur.execute("SELECT COUNT(*) FROM blacklist").fetchone()[0]

    embed = discord.Embed(title="üìä Bot Status", color=discord.Color.green())
    embed.add_field(name="üìù Registered", value=total)
    embed.add_field(name="üü¢ Online", value=len(online))
    embed.add_field(name="üî¥ Offline", value=len(offline))
    embed.add_field(name="üèÜ Already Picked", value=len(already_picked))
    embed.add_field(name="üö´ Blacklisted Users", value=total_blacklisted)
    await ctx.send(embed=embed, reference=ctx.message, mention_author=True)

# -------------------------
# on_message: VOX earning with cooldown
# -------------------------
@bot.event
async def on_message(message):
    if message.author.bot:
        return

    now = time.time()
    cooldown = 30  # seconds
    last = last_message_time.get(message.author.id, 0)

    if now - last >= cooldown:
        reward = 10  # VOX per eligible message (configured here)
        stats = user_stats.setdefault(message.author.id, {
            "registrations": 0, "wins": 0, "vox": 0,
            "tickets_total": 0, "tickets_available": 0, "tickets_used": 0, "tickets_committed": 0
        })
        stats["vox"] = stats.get("vox", 0) + reward
        db_update_currency(message.author.id, delta_vox=reward)
        last_message_time[message.author.id] = now

    await bot.process_commands(message)

# -------------------------
# UI: Show Wins view + Profile & Tickets UI
# -------------------------
class ShowWinsView(View):
    def __init__(self, user_id: int):
        super().__init__(timeout=120)
        self.user_id = user_id

    @discord.ui.button(label="Show Wins", style=discord.ButtonStyle.primary)
    async def show_wins_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id and not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("You can only view your own wins.", ephemeral=True)
            return
        wins = db_user_wins(self.user_id)
        if wins:
            lines = "\n".join(f"‚Ä¢ {name}" for name in wins)
        else:
            lines = "No wins yet."
        embed = discord.Embed(title="üèÜ Your Space Wins", description=lines, color=discord.Color.purple())
        await interaction.response.send_message(embed=embed, ephemeral=True)

class TicketActionsView(View):
    def __init__(self, user_id):
        super().__init__(timeout=60)
        self.user_id = user_id

    @discord.ui.button(label="Use Tickets", style=discord.ButtonStyle.green)
    async def use_tickets(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("‚ùå This isn‚Äôt your profile.", ephemeral=True)
            return

        # Prompt the user for input via chat
        await interaction.response.send_message(f"üé´ {interaction.user.mention}, how many tickets do you want to use?", ephemeral=True)
        
        def check(m):
            return m.author == interaction.user and m.channel == interaction.channel

        try:
            response = await bot.wait_for('message', check=check, timeout=30.0)
        except asyncio.TimeoutError:
            await interaction.followup.send(f"{interaction.user.mention}, you took too long to reply. The ticket commitment has been canceled.", ephemeral=True)
            return
        
        try:
            amount = int(response.content)
        except ValueError:
            await interaction.followup.send("‚ùå Please enter a valid number.", ephemeral=True)
            return

        stats = user_stats.setdefault(interaction.user.id, {
            "registrations": 0, "wins": 0, "vox": 0,
            "tickets_total": 0, "tickets_available": 0, "tickets_used": 0, "tickets_committed": 0
        })

        if amount <= 0:
            await interaction.followup.send("‚ùå You must commit at least 1 ticket.", ephemeral=True)
            return

        if stats["tickets_available"] < amount:
            await interaction.followup.send(f"‚ùå You only have {stats['tickets_available']} tickets available.", ephemeral=True)
            return

        stats["tickets_committed"] = amount
        db_update_currency(interaction.user.id, delta_available=-amount, delta_committed=amount)
        await interaction.followup.send(f"‚úÖ You committed {amount} ticket(s) for the next raffle!", ephemeral=True)
    
    @discord.ui.button(label="Buy Tickets", style=discord.ButtonStyle.blurple)
    async def buy_tickets(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("‚ùå This isn‚Äôt your profile.", ephemeral=True)
            return

        await interaction.response.send_message(f"üé´ {interaction.user.mention}, how many tickets do you want to buy?", ephemeral=True)

        def check(m):
            return m.author == interaction.user and m.channel == interaction.channel

        try:
            response = await bot.wait_for('message', check=check, timeout=30.0)
        except asyncio.TimeoutError:
            await interaction.followup.send(f"{interaction.user.mention}, you took too long to reply. The ticket purchase has been canceled.", ephemeral=True)
            return

        try:
            amount = int(response.content)
        except ValueError:
            await interaction.followup.send("‚ùå Please enter a valid number.", ephemeral=True)
            return

        if amount <= 0:
            await interaction.followup.send("‚ùå You must buy at least 1 ticket.", ephemeral=True)
            return

        stats = user_stats.setdefault(interaction.user.id, {
            "registrations": 0, "wins": 0, "vox": 0,
            "tickets_total": 0, "tickets_available": 0, "tickets_used": 0, "tickets_committed": 0
        })

        cost = amount * TICKET_PRICE
        if stats["vox"] < cost:
            await interaction.followup.send(f"‚ùå Not enough $VOX! You need {cost}, but only have {stats['vox']}.", ephemeral=True)
            return

        stats["vox"] -= cost
        stats["tickets_total"] += amount
        stats["tickets_available"] += amount
        db_update_currency(interaction.user.id, delta_vox=-cost, delta_total=amount, delta_available=amount)

        await interaction.followup.send(
            f"‚úÖ {interaction.user.mention} bought {amount} ticket(s) for {cost} $VOX!\n"
            f"üí∞ Remaining balance: {stats['vox']} $VOX\n"
            f"üéüÔ∏è Tickets ‚Üí Total: {stats['tickets_total']} | Available: {stats['tickets_available']} | Used: {stats['tickets_used']}",
            ephemeral=True
        )

class TicketsView(View):
    def __init__(self, user_id):
        super().__init__(timeout=60)
        self.user_id = user_id
        
        self.add_item(TicketActionsView(self.user_id))


@bot.command()
async def tickets(ctx, member: discord.Member = None):
    user = member or ctx.author
    stats = user_stats.setdefault(user.id, {
        "registrations": 0, "wins": 0, "vox": 0,
        "tickets_total": 0, "tickets_available": 0, "tickets_used": 0, "tickets_committed": 0
    })

    embed = discord.Embed(title=f"üéüÔ∏è Tickets - {user.display_name}", color=discord.Color.purple())
    embed.add_field(name="Total", value=stats["tickets_total"], inline=True)
    embed.add_field(name="Available", value=stats["tickets_available"], inline=True)
    embed.add_field(name="Used", value=stats["tickets_used"], inline=True)
    embed.add_field(name="Committed", value=stats.get("tickets_committed", 0), inline=True)

    view = TicketActionsView(user.id)
    await ctx.send(embed=embed, view=view)


class ProfileView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=60)
        self.user_id = user_id

    @discord.ui.button(label="Show Wins", style=discord.ButtonStyle.blurple)
    async def show_wins(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("‚ùå This isn‚Äôt your profile.", ephemeral=True)
            return
        wins = db_user_wins(self.user_id)
        if wins:
            lines = "\n".join(f"‚Ä¢ {name}" for name in wins)
        else:
            lines = "No wins yet."
        embed = discord.Embed(title="üèÜ Wins", description=lines, color=discord.Color.gold())
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label="Tickets", style=discord.ButtonStyle.green)
    async def show_tickets(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("‚ùå This isn‚Äôt your profile.", ephemeral=True)
            return

        stats = user_stats.get(self.user_id, {})
        total = stats.get("tickets_total", 0)
        available = stats.get("tickets_available", 0)
        used = stats.get("tickets_used", 0)
        committed = stats.get("tickets_committed", 0)

        embed = discord.Embed(title="üéüÔ∏è Ticket Stats", color=discord.Color.purple())
        embed.add_field(name="Total Tickets", value=f"{total} üéüÔ∏è", inline=True)
        embed.add_field(name="Available", value=f"{available} ‚úÖ", inline=True)
        embed.add_field(name="Used", value=f"{used} ‚ùå", inline=True)
        embed.add_field(name="Committed", value=f"{committed} üéØ", inline=True)

        view = TicketActionsView(self.user_id)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

@bot.command()
async def profile(ctx, member: discord.Member = None):
    user = member or ctx.author
    link = user_links.get(user.id, "Not registered")
    
    # Ensure a complete stats dictionary is initialized for the user
    stats = user_stats.setdefault(user.id, {
        "registrations": 0,
        "wins": 0,
        "vox": 0,
        "tickets_total": 0,
        "tickets_available": 0,
        "tickets_used": 0,
        "tickets_committed": 0
    })

    wins = stats["wins"]
    vox = stats.get("vox", 0)
    total_tickets = stats.get("tickets_total", 0)

    # Status indicator based on Discord member status
    status_map = {
        discord.Status.online: "üü¢ Online",
        discord.Status.idle: "üåô Away",
        discord.Status.dnd: "‚õî Do Not Disturb",
        discord.Status.offline: "‚ö´ Offline",
    }
    status_text = status_map.get(user.status, "‚ùì Unknown")

    ranks = [
        (0, 5, "üå± Newbie", "üå±"),
        (6, 10, "üéØ Amateur", "üéØ"),
        (11, 15, "üõ°Ô∏è Experienced", "üõ°Ô∏è"),
        (16, 20, "‚ö° Skilled", "‚ö°"),
        (21, 25, "üî• Advanced", "üî•"),
        (26, 30, "üèÜ Pro", "üèÜ"),
        (31, float("inf"), "üëë Legend", "üëë"),
    ]

    rank_name, rank_emoji, progress = "Unranked", "‚ùî", 0
    for lower, upper, name, emoji in ranks:
        if lower <= wins <= upper:
            rank_name, rank_emoji = name, emoji
            next_threshold = upper if upper != float("inf") else None
            progress = 10 if not next_threshold else int((wins - lower) / (upper - lower + 1) * 10)
            break

    bar = "‚ñ†" * progress + "‚ñ°" * (10 - progress)
    percent = int(progress * 10)

    embed = discord.Embed(color=discord.Color.blue())
    embed.set_author(name=f"{user.display_name}'s Profile", icon_url=user.display_avatar.url)
    embed.description = (
        f"üë§ Profile: {user.mention} ({status_text})\n"
        f"üåê X Link: {link}\n\n"
        f"üìä Stats:\n"
        f"- üìù Registrations: {stats['registrations']}\n"
        f"- üèÜ Wins: {wins}\n"
        f"- üéñÔ∏è Rank: {rank_emoji} {rank_name}\n"
        f"- üîã Progress: [{bar}] {percent}%\n"
        f"- üí∞ $VOX: {vox}\n"
        f"- üé´ Tickets: {total_tickets}\n"
    )
    view = ProfileView(user.id)
    await ctx.send(embed=embed, view=view, reference=ctx.message, mention_author=True)

# -------------------------
# Always-pick commands
# -------------------------
@bot.command()
@commands.has_permissions(administrator=True)
async def always_add(ctx, member: discord.Member):
    always_pick.add(member.id)
    db_set_always(member.id, add=True)
    await ctx.send(f"‚úÖ {member.mention} added to always-pick list.")

@bot.command()
@commands.has_permissions(administrator=True)
async def always_remove(ctx, member: discord.Member):
    always_pick.discard(member.id)
    db_set_always(member.id, add=False)
    await ctx.send(f"‚ùå {member.mention} removed.")

@bot.command()
@commands.has_permissions(administrator=True)
async def always_list(ctx):
    if not always_pick:
        await ctx.send("‚ö†Ô∏è No users in always-pick list.")
        return
    members = [ctx.guild.get_member(uid).mention for uid in always_pick if ctx.guild.get_member(uid)]
    await ctx.send("üëë Always-pick list:\n" + ", ".join(members))

# -------------------------
# Ticket admin/user commands
# -------------------------
@bot.command()
@commands.has_permissions(administrator=True)
async def set_ticket_price(ctx, price: int):
    global TICKET_PRICE
    if price <= 0:
        await ctx.send("‚ùå Ticket price must be a positive integer.")
        return
    TICKET_PRICE = price
    await ctx.send(f"üéüÔ∏è Ticket price set to {TICKET_PRICE} $VOX")

@bot.command()
@commands.has_permissions(administrator=True)
async def award_vox(ctx, member: discord.Member, amount: int):
    if amount <= 0:
        await ctx.send("‚ùå Amount must be positive.")
        return
    stats = user_stats.setdefault(member.id, {
        "registrations": 0, "wins": 0, "vox": 0,
        "tickets_total": 0, "tickets_available": 0, "tickets_used": 0, "tickets_committed": 0
    })
    stats["vox"] = stats.get("vox", 0) + amount
    db_update_currency(member.id, delta_vox=amount)
    await ctx.send(f"üí∞ {member.mention} awarded {amount} $VOX. Total: {stats['vox']} $VOX")

@bot.command()
async def buy_ticket(ctx):
    # Prompt the user for input
    prompt_message = await ctx.send(f"üé´ {ctx.author.mention}, how many tickets do you want to buy?")
    
    def check(m):
        return m.author == ctx.author and m.channel == ctx.channel

    try:
        response = await bot.wait_for('message', check=check, timeout=30.0)
    except asyncio.TimeoutError:
        await ctx.send(f"{ctx.author.mention}, you took too long to reply. The ticket purchase has been canceled.")
        return

    try:
        amount = int(response.content)
    except ValueError:
        await ctx.send("‚ùå Please enter a valid number.", reference=response)
        return

    if amount <= 0:
        await ctx.send("‚ùå You must buy at least 1 ticket.")
        return

    stats = user_stats.setdefault(ctx.author.id, {
        "registrations": 0, "wins": 0, "vox": 0,
        "tickets_total": 0, "tickets_available": 0, "tickets_used": 0, "tickets_committed": 0
    })

    cost = amount * TICKET_PRICE
    if stats["vox"] < cost:
        await ctx.send(f"‚ùå Not enough $VOX! You need {cost}, but only have {stats['vox']}.")
        return

    stats["vox"] -= cost
    stats["tickets_total"] += amount
    stats["tickets_available"] += amount
    db_update_currency(ctx.author.id, delta_vox=-cost, delta_total=amount, delta_available=amount)

    await ctx.send(
        f"‚úÖ {ctx.author.mention} bought {amount} ticket(s) for {cost} $VOX!\n"
        f"üí∞ Remaining balance: {stats['vox']} $VOX\n"
        f"üéüÔ∏è Tickets ‚Üí Total: {stats['tickets_total']} | Available: {stats['tickets_available']} | Used: {stats['tickets_used']}"
    )

# -------------------------
# Export helpers (unchanged logic)
# -------------------------
def build_rows_for_raffle(guild: discord.Guild, raffle_name: str):
    rows = [["S/N", "Discord Name", "X Username", "X Link"]]
    winners = []
    if raffle_name in raffles:
        winners = raffles.get(raffle_name, [])
    else:
        with db_conn() as con:
            cur = con.cursor()
            winners = [r[0] for r in cur.execute(
                "SELECT user_id FROM raffle_winners WHERE raffle_name=? ORDER BY picked_at ASC", (raffle_name,)
            )]
    for sn, uid in enumerate(winners, start=1):
        member = guild.get_member(uid)
        display = member.display_name if member else f"User {uid}"
        x_link = user_links.get(uid, "")
        username = x_link.split("/")[-1] if x_link else "-"
        rows.append([sn, display, username, x_link])
    return rows

def export_excel(guild: discord.Guild, raffle_name: str) -> str:
    rows = build_rows_for_raffle(guild, raffle_name)
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = raffle_name[:31] if raffle_name else "Sheet1"
    for r in rows:
        ws.append(r)
    file_path = f"{raffle_name}_winners.xlsx"
    wb.save(file_path)
    return file_path

def export_pdf(guild: discord.Guild, raffle_name: str) -> str:
    rows = build_rows_for_raffle(guild, raffle_name)
    file_path = f"{raffle_name}_winners.pdf"
    doc = SimpleDocTemplate(file_path, pagesize=A4, title=f"{raffle_name} Winners")
    styles = getSampleStyleSheet()
    elements = []
    elements.append(Paragraph(f"üéâ Winners - {raffle_name} (Space)", styles['Title']))
    elements.append(Spacer(1, 12))
    table = Table(rows, repeatRows=1)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0,0), (-1,0), colors.gold),
        ('TEXTCOLOR', (0,0), (-1,0), colors.black),
        ('GRID', (0,0), (-1,-1), 0.5, colors.grey),
        ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold'),
        ('ALIGN', (0,0), (-1,-1), 'LEFT'),
        ('ROWBACKGROUNDS', (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
    ]))
    elements.append(table)
    doc.build(elements)
    return file_path

def export_png(guild: discord.Guild, raffle_name: str) -> str:
    if not PIL_AVAILABLE:
        raise RuntimeError("Pillow not installed; PNG export unavailable.")
    rows = build_rows_for_raffle(guild, raffle_name)
    col_widths = [60, 260, 200, 420]
    padding = 12
    row_h = 36
    width = sum(col_widths) + padding*2
    height = row_h * (len(rows)+1) + padding*2
    img = Image.new("RGB", (width, height), "white")
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("arial.ttf", 18)
        font_b = ImageFont.truetype("arial.ttf", 20)
    except Exception:
        font = ImageFont.load_default()
        font_b = font
    y = padding
    draw.text((padding, y), f"Winners - {raffle_name} (Space)", font=font_b, fill="black")
    y += row_h
    x = padding
    draw.rectangle([x, y, width-padding, y+row_h], outline="black", fill="#ffd166")
    headers = rows[0]
    cx = x
    for i, head in enumerate(headers):
        draw.text((cx+8, y+8), str(head), font=font_b, fill="black")
        cx += col_widths[i]
        draw.line([(cx, y), (cx, y+row_h)], fill="black", width=1)
    draw.rectangle([x, y, width-padding, y+row_h], outline="black", width=1)
    y += row_h
    for r in rows[1:]:
        cx = x
        for i, cell in enumerate(r):
            draw.text((cx+8, y+8), str(cell), font=font, fill="black")
            cx += col_widths[i]
            draw.line([(cx, y), (cx, y+row_h)], fill="#888888", width=1)
        draw.rectangle([x, y, width-padding, y+row_h], outline="#888888", width=1)
        y += row_h
    file_path = f"{raffle_name}_winners.png"
    img.save(file_path)
    return file_path

# Export UI and related commands kept (omitted here for brevity if unchanged)
# ... (You already have export/UI code earlier in the file ‚Äî kept unchanged)

@bot.command()
async def export(ctx):
    active = db_get_active_raffles()
    if not active:
        await ctx.send("‚ö†Ô∏è No active spaces available.")
        return
    embed = discord.Embed(
        title="üì§ Export Winners (Spaces)",
        description="Select a **space** to export, then choose **PNG / EXCEL / PDF**.\n"
                    "- PNG/PDF: visible to everyone in the channel.\n"
                    "- Excel: admin-only (you‚Äôll get it ephemerally).",
        color=discord.Color.gold()
    )
    await ctx.send(embed=embed, view=RaffleDropdown(archived=False))

@bot.command(name="archive")
async def list_archived(ctx):
    archived = db_get_archived_raffles()
    if not archived:
        await ctx.send("üì¶ No archived spaces yet.")
        return
    embed = discord.Embed(
        title="üì¶ Archived Spaces",
        description="Select an **archived space** to export its winners.",
        color=discord.Color.blurple()
    )
    await ctx.send(embed=embed, view=RaffleDropdown(archived=True))

@bot.command()
@commands.has_permissions(administrator=True)
async def reset_db(ctx):
    conn = db_conn()
    c = conn.cursor()
    c.execute("DELETE FROM users")
    c.execute("DELETE FROM raffles")
    c.execute("DELETE FROM stats")
    c.execute("DELETE FROM currency")
    c.execute("DELETE FROM raffle_winners")
    c.execute("DELETE FROM picks_state")
    conn.commit()
    conn.close()

    user_links.clear()
    raffles.clear()
    user_stats.clear()
    already_picked.clear()
    always_pick.clear()

    await ctx.send("‚úÖ Database has been reset (all users, raffles, stats cleared).")

@bot.command()
@commands.has_permissions(administrator=True)
async def reset_raffles(ctx):
    conn = db_conn()
    c = conn.cursor()
    c.execute("DELETE FROM raffles")
    c.execute("DELETE FROM raffle_winners")
    c.execute("DELETE FROM picks_state")
    c.execute("UPDATE currency SET tickets_total = 0, tickets_available = 0, tickets_used = 0, tickets_committed = 0")
    c.execute("UPDATE stats SET wins = 0")
    conn.commit()
    conn.close()

    raffles.clear()
    user_stats.clear()
    already_picked.clear()

    await ctx.send("‚úÖ Raffles and stats have been reset. Registered users remain.")

# -------------------------
# ‚ñ∂Ô∏è Run Bot
# -------------------------
bot.run(TOKEN)